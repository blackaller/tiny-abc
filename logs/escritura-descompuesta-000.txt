Last login: Sun Jan 25 21:08:38 on ttys002
black-iMac:~ black$ cd /Library/WebServer/Documents/tiny-abc/
black-iMac:tiny-abc black$ ls -la
total 48
drwxr-xr-x  10 black  wheel   340 Dec 23 19:57 .
drwxr-xr-x+ 42 root   wheel  1428 Dec  8 20:58 ..
-rw-r--r--@  1 black  wheel  6148 Nov  4 21:40 .DS_Store
drwxr-xr-x  16 black  wheel   544 Dec 23 20:00 .git
-rw-r--r--   1 black  wheel    46 Nov  4 21:35 README.md
-rw-r--r--   1 black  wheel   393 Nov 30 20:02 escritura-descompuesta.html
-rw-r--r--   1 black  wheel   340 Nov  4 21:45 index.html
drwxr-xr-x   3 black  wheel   102 Dec 17 22:07 js
-rw-r--r--   1 black  wheel  1368 Dec 23 20:02 nltk_testing.py
drwxr-xr-x   3 black  wheel   102 Dec  6 13:03 txt
black-iMac:tiny-abc black$ python
Python 2.7.6 (default, Sep  9 2014, 15:04:36) 
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> ## using the natural language toolkit http://www.nltk.org/
... from __future__ import division  ## Python 2 users only
>>> import nltk, re, pprint
>>> from nltk import word_tokenize
>>> from urllib import urlopen
>>> ## get text from URL
... my_url = 'https://raw.githubusercontent.com/blackaller/tiny-abc/master/txt/escritura-descompuesta.txt' # path to file online
>>> response = urlopen(my_url)
>>> my_text = response.read().decode('utf8')
>>> print my_text
0.
Hace tiempo un profesor me hizo la siguiente consulta “¿Qué te gusta más, y qué te cuesta más trabajo, escribir ensayos, o códigos de programación?” En principio su pregunta me pareció torpe y desatinada. No es posible comparar ambos procesos; son demasiado diferentes. No puedo saber cual me gusta más. Cuando escribo un ensayo, o cualquier otro texto que hace uso del lenguaje natural, lo hago para que otro ser humano —mi lector— entienda un aspecto u otro del tema que me concierne, si tengo suerte hilando ecos de mi palabra en el monólogo de su pensamiento. Mi objetivo es poder decir algo, y la dificultad radica en articular con claridad, elegancia y convicción la maraña de argumentos en mi cabeza. Cuando escribo un programa de computadora, en cambio, mi objetivo es preparar un instructivo que la computadora usará para ejecutar un conjunto de procesos previamente diseñados por mí o por alguien más.
1.
“No estoy seguro que pueda responder a tu pregunta”, le dije. “Para mí, la escritura y la programación son universos prácticamente ajenos.”— Mi evasiva respuesta pareció satisfacer al profesor, pero a mí me dejó confundido. Por banal que pudiera parecer, la existencia de su pregunta me abrió las puertas a un complejo laberinto multidimensional, repleto de niveles y espejismos. En su caprichosa configuración, el laberinto me invitó a ignorar los condicionales determinados por el contexto —“escribir sirve para esto, programar sirve para esto, etcétera”— e imaginar la escritura como el proceso [humano] de manipular los caracteres de un alfabeto para producir secuencias finitas de contenido inteligible.
2.
En estos términos una carta, una novela, el código fuente de una página web, o una demostración matemática son el resultado de acciones similares. Esta visión cibernética entiende al escritor (o programador) como una caja negra que produce un texto en función de un estímulo. Al igual que le ocurrió al cuadrilátero tocado por una manzana en Flatland, de momento pude ver el espacio en que habitan todas las formas de escribir conocidas por el ser humano en su historia. La matemática, el lenguaje natural y su literatura, la escritura musical y los lenguajes de programación aparecieron ante mí en forma dinámica y tangible. Configuraciones imposibles de información cobraban sentido al momento de ser vistas, como evocaciones de algo parecido a las escaleras de grafito en las catacumbas de un dibujo de M. C. Escher.
3.
Sin un sistema de representación simbólica como la escritura, estas modalidades del pensamiento carecen de perseverancia y profundidad. La escritura es en primer lugar memoria, la única defensa en contra del efecto devastador del tiempo. Pero también es evocación, guía y recetario. No es casualidad que las primeras obras literarias escritas por la humanidad —de carácter mitológico y religioso— sean en su mayoría guías de conducta, es decir, sistemas morales de programación social. En su modalidad imperativa, el lenguaje natural es un lenguaje de programación, y el texto escrito es un programa.
4.
En su modalidad de información, el resultado de un proceso de escritura se reduce a un problema de enumeración combinatoria. Basta contar con el tiempo necesario, y una máquina de producción aleatoria de secuencias de caracteres generará cualquier expresión literaria o especulación científica jamás concebida. “El tiempo necesario”, por supuesto, es una cantidad fuera del alcance de la dimensión humana, incluso en términos cósmicos. No hay suficiente materia en el universo para contar siquiera el más pequeño de los infinitos, ni hay suficientes minutos en la eternidad para contar el total de los números reales, a pesar de que la eternidad es, en sí misma, un infinito. Perdido en el espacio entre ahora y el fin del tiempo existe un número que cuenta todos los textos jamás escritos, pero este número está fuera de nuestro alcance. En términos prácticos, el programa generador de “cualquier texto posible” es un objeto teórico que no podrá existir en términos definidos por la escala humana. Ante semejantes posibilidades la escala humana enfrenta el absurdo.
5.
Tres años antes de hacerme la pregunta que me confundió hace un par de párrafos, el mismo profesor escribió un libro llamado Creative Code, o Código Creativo. En principio, ese título me pareció tan torpe y desatinado como su pregunta —el acto de programar es en general un acto esencialmente creativo— pero al cabo de pensar un rato, me perdí de nuevo en un intrincado sistema de proposiciones ambivalentes alrededor de la escritura, la programación, el texto y el código. El contenido del libro explora el potencial del medio digital a través de una serie de experimentos en diseño de interfaces que buscan trascender el uso principalmente utilitario que se atribuye a la computadora en nuestro tiempo. La tesis del profesor es que los autores de dichos experimentos pertenecen a una clase creativa especial, y son capaces de actuar en paralelo como programadores y como diseñadores. Esta “ventaja” supuestamente les permite trascender los paradigmas convencionales de diseño digital en que se ven atrapados los programadores que no saben diseñar cuando trabajan con diseñadores que no saben programar. Por esta razón, me parece que el título del libro quiere significar Programación Creativa, o “programación que requiere un tipo de creatividad especial”,  pero en realidad Código Creativo quiere decir otra cosa: Código capaz de crear. Y en este sentido las doscientas cincuenta y seis páginas del libro del profesor no arrojan ninguna luz ante la posibilidad de que un programa de computadora pueda escribir un texto literario sin que esta habilidad haya sido incorporada como parte del programa en cierta medida por el programador. En el contexto de un sistema humano-computacional en acción —por ejemplo, un usuario cualquiera escribiendo en su computadora portátil, o sacando fotos con su teléfono celular— es el componente humano quien es responsable del aspecto creativo en la relación.
6.
El código de un programa de computadora puede describir el comportamiento de un sistema de comunicación, o los procesos que habrán de simular el metabolismo de un organismo biológico. En estos términos, un estudio cualitativo del proceso humano de creación literaria puede ayudar a definir mecanismos y estrategias que permitirán mejores resultados al diseñar un programa capaz de crear. Al escribir un texto narrativo, el autor se coloca a sí mismo dentro de un laberinto que le permite seguir [o trazar] los puntos de vista, motivaciones, estado emocional, influencias y decisiones de cada uno de sus personajes. La narración va dibujando una gráfica dirigida entre personajes, situaciones y acciones, conectados en función de importancia y causalidad. Los caminos a seguir, dónde comenzar, hacia dónde dirigir la mirada, cuándo recordar información relevante o saltar a la cabeza de otro personaje son decisiones que el autor hace en función del efecto que busca provocar en su lector imaginario. Sin saber de antemano la trama causal de la narración completa, el autor se ve forzado a decidir cada vez que uno de sus personajes enfrenta una disyuntiva. Para el programador, es el programa quien idealmente será responsable de tomar cada decisión enfrentada por el autor. Al escribir un programa que escribe novelas, el programador buscará generar (o definir) el espacio y contexto de los acontecimientos en que ocurre la narración en forma de datos, y un proceso subsecuente buscará la mejor manera de cubrir estos acontecimientos en función de una determinada intención narrativa. Los problemas creativos enfrentados por el autor serán considerados en términos cuantitativos y transformados en procesos computables. El programador intentará describir en términos formales conceptos que el autor literario intuye con naturalidad, como lo son estilo e intención narrativa, o inventar un proceso computacional capaz de determinarlos.
7.
En términos literarios aceptamos por definición que la versión de Shakespeare es la encarnación correcta en que Macbeth debe ser narrado y puesto en escena, pero no tenemos herramientas que validen este acto de fe cultural. ¿Cómo podemos estar seguros? Cuando Pierre Menard volvió a escribir el Quijote, su conexión mental con el espacio de todo lo escrito le permitió acceso al registro en que la versión escrita por Cervantes estaba guardada —¿pero qué si hubiera encontrado una versión modificada, o simplemente diferente, tal vez mejor en cierto sentido que la versión original?
8.
El conjunto de “todo texto escrito en cualquier lenguaje que haya gozado de suficiente valor cultural en determinado momento para alguna cultura humana” no es el conjunto vacío. La obra literaria de todos mis autores favoritos pertenece a este conjunto, al igual que todo texto importante de naturaleza científica, y el código fuente de programas de computadora relevantes, incluyendo los sitios de internet más importantes nuestro tiempo. La reciente inclusión del programa de computadora en este conjunto transforma la idea que normalmente se tiene de un texto. En cierto sentido la expande. A pesar de ser escrito en una combinación de lenguaje natural y formal, el código fuente de un sitio de internet —el de la página de búsqueda de Google,  por ejemplo— fue escrito para computadoras y robots, pero permanece legible para seres humanos iniciados en el discurso digital. En su naturaleza de conjunto de instrucciones que dirigen el funcionamiento de una red de experiencias digitales interactivas, dicho código fuente ha sufrido múltiples iteraciones en el intervalo relativamente corto de su existencia, y será conservado históricamente no como el texto terminado al que nos acostumbró la idea de autor en la era moderna europea, sino como un sistema de contenidos en flujo, continuamente revisados y modificados por un enjambre de autores en colaboración, solamente interrumpidos por la pausa o terminación de su ciclo de ejecución. Más semejante a un organismo viviente que a un libro, el código de un programa de computadora es más parecido en su evolución a las formas literarias que se han propagado y conservado por medio de la tradición oral en culturas carentes de sistemas adecuados de escritura.
9.
Si bien la escritura del código de un programa digital y el texto de una obra literaria parecen requerir mentalidades diferentes, el espacio de intersección entre ambos procesos ha servido como fuente de inspiración a múltiples autores. Décadas antes de que la computadora pudiera ser programada con fines prácticos, autores como Lem, Borges,  Perec y Queneau incorporaron ideas matemáticas y métodos computacionales al quehacer de su literatura. La reciente adopción masiva de la computadora como medio universal de comunicación ha visto emerger una nueva clase de autor, que trata el código de programación y el texto literario como partes entrelazadas del acto mental de pensar y escribir en la era digital, produciendo programas que generan, manipulan o transforman el resultado que se presenta al lector, en muchos casos en colaboración con el mismo lector.
10.
En el caso de la lectura la diferencia parece permanecer insalvable, y es difícil encontrar un espacio de intersección. Cuando se trata de leer, el código de programación es ingerido en forma similar a un texto de matemáticas o una partida de ajedrez, con la intención principal de aprender cómo resolver un problema, o delinear una estrategia para ejecutar un proceso. Este tipo de lectura no es un fin en si mismo, sino un medio dedicado a servir otros propósitos, y difiere fundamentalmente del proceso de lectura que requiere la obra literaria precisamente en eso. La lectura del texto literario es un fin en sí mismo, es su razón de ser. El texto literario existe para ser leído, y el código de programación existe para ejecutar un programa.
11.
De haber intercambiado la palabra escribir por la palabra leer en la pregunta que dio inicio a este texto, mi respuesta inmediata hubiera sido “Me gusta más leer ensayos, y me cuesta más trabajo leer códigos de programación”. La naturaleza esencialmente diferente de ambos tipos de lectura me permite decidir sin lugar a dudas. Por el contrario, al considerar ambos tipos de escritura enfrenté un inminente conflicto moral ¿Cómo atreverme a preferir el uno sobre el otro? Sería como atreverme a preferir Poesía sobre Geometría, Topología sobre tragedia, o enfrentar a Homero contra Pitágoras en un absurdo sueño de lucha libre dominical. Diez mil quinientos veintisiete caracteres más tarde, me encuentro de vuelta en el punto de partida, atrapado en el abismo existencial de mis propias palabras. Puedo comparar pero no quiero decidir.
>>> my_tokens = word_tokenize(my_text)
>>> len(my_tokens)
2230
>>> my_nltext = nltk.Text(my_tokens)
>>> ## some rough cleanup. need to be more delicate
... my_words = [w.lower() for w in my_nltext if w.isalpha()] ## losing some words here because of unclean elements like "—something"
>>> my_nltext.collocations() ## collocations are expressions of multiple words which commonly co-occur
lenguaje natural; código fuente; obra literaria; texto literario;
gusta más; para ejecutar; Código Creativo; intención narrativa; sus
personajes; Cuando escribo; ambos tipos; cierto sentido; escala
humana; las formas; tiempo necesario; cuesta más; más trabajo; del
libro; para esto; sirve para
>>> my_vocabulary = sorted(set(my_words))
>>> print my_vocabulary[0:55]
[u'a', u'abismo', u'abri\xf3', u'absurdo', u'acceso', u'acciones', u'acci\xf3n', u'aceptamos', u'acontecimientos', u'acostumbr\xf3', u'acto', u'actuar', u'adecuados', u'adopci\xf3n', u'ahora', u'ajedrez', u'ajenos', u'al', u'alcance', u'aleatoria', u'alfabeto', u'algo', u'alguien', u'alguna', u'alrededor', u'ambivalentes', u'ambos', u'ante', u'antemano', u'antes', u'aparecieron', u'aprender', u'argumentos', u'arrojan', u'articular', u'aspecto', u'atrapado', u'atrapados', u'atreverme', u'atribuye', u'autor', u'autores', u'ayudar', u'a\xf1os', u'banal', u'basta', u'bien', u'biol\xf3gico', u'borges', u'busca', u'buscan', u'buscar\xe1', u'b\xfasqueda', u'cabeza', u'cabo']
>>> for w in my_vocabulary[0:55]:
...     print w
... 
a
abismo
abrió
absurdo
acceso
acciones
acción
aceptamos
acontecimientos
acostumbró
acto
actuar
adecuados
adopción
ahora
ajedrez
ajenos
al
alcance
aleatoria
alfabeto
algo
alguien
alguna
alrededor
ambivalentes
ambos
ante
antemano
antes
aparecieron
aprender
argumentos
arrojan
articular
aspecto
atrapado
atrapados
atreverme
atribuye
autor
autores
ayudar
años
banal
basta
bien
biológico
borges
busca
buscan
buscará
búsqueda
cabeza
cabo
>>> fr_dist1 = nltk.FreqDist(my_nltext)
>>> hapaxes = fr_dist1.hapaxes() ## words that occur only once
>>> len(my_vocabulary)
770
>>> len(hapaxes)
570
>>> clean_hapaxes = [w.lower() for w in hapaxes if w.isalpha()]
>>> sorted_hapaxes = sorted(set(clean_hapaxes)) ## losing some words again for the same reason we did before
>>> len(sorted_hapaxes)
553
>>> print sorted_hapaxes[0:55]
[u'a', u'abismo', u'abri\xf3', u'acceso', u'acci\xf3n', u'aceptamos', u'acostumbr\xf3', u'actuar', u'adecuados', u'adopci\xf3n', u'ahora', u'ajedrez', u'ajenos', u'aleatoria', u'alfabeto', u'alguien', u'alguna', u'alrededor', u'ambivalentes', u'ante', u'antemano', u'aparecieron', u'aprender', u'argumentos', u'arrojan', u'articular', u'atrapado', u'atrapados', u'atribuye', u'ayudar', u'a\xf1os', u'banal', u'basta', u'bien', u'biol\xf3gico', u'borges', u'busca', u'buscan', u'b\xfasqueda', u'cabo', u'caja', u'cambio', u'caminos', u'cantidad', u'capaces', u'caprichosa', u'carecen', u'carentes', u'carta', u'car\xe1cter', u'caso', u'casos', u'casualidad', u'catacumbas', u'causal']
>>> for w in sorted_hapaxes[0:55]:
...     print w
... 
a
abismo
abrió
acceso
acción
aceptamos
acostumbró
actuar
adecuados
adopción
ahora
ajedrez
ajenos
aleatoria
alfabeto
alguien
alguna
alrededor
ambivalentes
ante
antemano
aparecieron
aprender
argumentos
arrojan
articular
atrapado
atrapados
atribuye
ayudar
años
banal
basta
bien
biológico
borges
busca
buscan
búsqueda
cabo
caja
cambio
caminos
cantidad
capaces
caprichosa
carecen
carentes
carta
carácter
caso
casos
casualidad
catacumbas
causal
>>> nltk.FreqDist(my_words).plot(50, cumulative=True)
>>> nltk.FreqDist([w.lower() for w in my_nltext if w.isalpha() and len(w) > 3]).plot(50, cumulative=True) 
>>> exit()
